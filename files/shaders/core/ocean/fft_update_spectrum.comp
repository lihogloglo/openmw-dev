#version 430 core

// FFT Ocean Spectrum Update Shader
// Updates the wave spectrum H(k,t) based on dispersion relation

layout(local_size_x = 16, local_size_y = 16) in;

// Input: Initial spectrum H0(k) and H0*(-k)
layout(binding = 0, rgba32f) uniform image2D uH0Texture;

// Output: Time-evolved spectrum H(k,t)
layout(binding = 1, rgba32f) uniform image2D uHtTexture;

// Uniforms
uniform float uTime;           // Current simulation time
uniform float uTileSize;       // Physical size of this cascade in meters
uniform float uGravity;        // Gravitational constant (9.81 m/s^2)

const float PI = 3.14159265359;

// Complex number multiplication
vec2 complexMult(vec2 a, vec2 b)
{
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

// Complex conjugate
vec2 complexConj(vec2 z)
{
    return vec2(z.x, -z.y);
}

void main()
{
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(uH0Texture);

    if (coord.x >= size.x || coord.y >= size.y)
        return;

    // Wave vector k
    vec2 k = vec2(
        (float(coord.x) - float(size.x) / 2.0) * 2.0 * PI / uTileSize,
        (float(coord.y) - float(size.y) / 2.0) * 2.0 * PI / uTileSize
    );

    float kLength = length(k);

    // Dispersion relation: omega = sqrt(g * k)
    // For deep water waves
    float omega = sqrt(uGravity * kLength);

    // Read initial spectrum
    vec4 h0Data = imageLoad(uH0Texture, coord);
    vec2 h0k = h0Data.xy;      // H0(k)
    vec2 h0minusk = h0Data.zw; // H0(-k) conjugate

    // Time evolution: H(k,t) = H0(k) * e^(i*omega*t) + H0*(-k) * e^(-i*omega*t)
    float angle = omega * uTime;
    vec2 expIwt = vec2(cos(angle), sin(angle));
    vec2 expMinusIwt = vec2(cos(angle), -sin(angle));

    vec2 hkt = complexMult(h0k, expIwt) + complexMult(h0minusk, expMinusIwt);

    // Store result (real and imaginary parts)
    imageStore(uHtTexture, coord, vec4(hkt, 0.0, 0.0));
}
