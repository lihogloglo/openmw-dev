#version 430 core

// FFT Butterfly Shader
// Performs one stage of the FFT using the Cooley-Tukey algorithm

layout(local_size_x = 16, local_size_y = 16) in;

// Input texture
layout(binding = 0, rgba32f) uniform image2D uInputTexture;

// Output texture
layout(binding = 1, rgba32f) uniform image2D uOutputTexture;

// Butterfly texture (precomputed twiddle factors)
layout(binding = 2) uniform sampler2D uButterflyTexture;

// Uniforms
uniform int uStage;        // Current FFT stage (0 to log2(N))
uniform bool uHorizontal;  // true for horizontal pass, false for vertical

// Complex number multiplication
vec2 complexMult(vec2 a, vec2 b)
{
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

void main()
{
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(uInputTexture);

    if (coord.x >= size.x || coord.y >= size.y)
        return;

    // Determine which index we're processing
    int index = uHorizontal ? coord.x : coord.y;

    // Fetch butterfly data for this stage and index
    vec4 butterflyData = texelFetch(uButterflyTexture, ivec2(index, uStage), 0);
    vec2 twiddle = butterflyData.xy;     // Twiddle factor (complex number)
    int topWing = int(butterflyData.z);
    int bottomWing = int(butterflyData.w);

    // Fetch values from top and bottom wings
    ivec2 topCoord = uHorizontal ? ivec2(topWing, coord.y) : ivec2(coord.x, topWing);
    ivec2 bottomCoord = uHorizontal ? ivec2(bottomWing, coord.y) : ivec2(coord.x, bottomWing);

    vec2 topValue = imageLoad(uInputTexture, topCoord).xy;
    vec2 bottomValue = imageLoad(uInputTexture, bottomCoord).xy;

    // Butterfly operation: output = top + twiddle * bottom
    vec2 result = topValue + complexMult(twiddle, bottomValue);

    // Store result
    imageStore(uOutputTexture, coord, vec4(result, 0.0, 0.0));
}
