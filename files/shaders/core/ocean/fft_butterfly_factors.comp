#version 440 core
/**
 * Precomputes the butterfly factors for a Stockham FFT kernel
 *
 * Ported from GodotOceanWaves by 2Retr0
 */

#define PI (3.141592653589793)

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Output: Butterfly factors buffer - log2(map_size) x map_size
layout(std430, binding = 0) writeonly buffer ButterflyFactorBuffer {
    vec4 butterfly[]; // log2(map_size) x map_size
};

uniform uint uMapSize; // Must be power of 2

/** Returns exp(j*x) assuming x >= 0. */
vec2 exp_complex(in float x) {
    return vec2(cos(x), sin(x));
}

#define BUTTERFLY(col, stage) (butterfly[(stage)*uMapSize + (col)])

void main() {
    const uint col = gl_GlobalInvocationID.x;   // Column in row
    const uint stage = gl_GlobalInvocationID.y; // Stage of FFT

    if (col >= uMapSize)
        return;

    uint stride = 1 << stage;
    uint mid = uMapSize >> (stage + 1);
    uint i = col >> stage;
    uint j = col % stride;

    vec2 twiddle_factor = exp_complex(PI / float(stride) * float(j));
    uint r0 = stride*(i +   0) + j;
    uint r1 = stride*(i + mid) + j;
    uint w0 = stride*(2*i + 0) + j;
    uint w1 = stride*(2*i + 1) + j;

    vec2 read_indices = vec2(uintBitsToFloat(r0), uintBitsToFloat(r1));

    BUTTERFLY(w0, stage) = vec4(read_indices,  twiddle_factor);
    BUTTERFLY(w1, stage) = vec4(read_indices, -twiddle_factor);
}
