#version 440 core
/**
 * Modulates the JONSWAP wave spectra texture in time and calculates
 * its gradients. Since the outputs are all real-valued, they are packed
 * in pairs.
 *
 * Ported from GodotOceanWaves by 2Retr0
 * Sources: Jerry Tessendorf - Simulating Ocean Water
 *          Robert Matusiak - Implementing Fast Fourier Transform Algorithms of Real-Valued Sequences With the TMS320 DSP Platform
 */

#define PI          (3.141592653589793)
#define G           (9.81)
#define NUM_SPECTRA (4U)

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Input: Initial spectrum from spectrum_compute
layout(binding = 0, rgba16f) restrict readonly uniform image2D spectrum;

// Output: FFT buffer (SSBO) - map_size x map_size x num_spectra x 2
layout(std430, binding = 1) restrict writeonly buffer FFTBuffer {
    vec2 data[]; // map_size x map_size x num_spectra x 2
};

// Uniforms (converted from push constants)
uniform vec2 uTileLength;
uniform float uDepth;
uniform float uTime;
uniform uint uMapSize; // Resolution of the map

/** Returns exp(j*x) assuming x >= 0. */
vec2 exp_complex(in float x) {
    return vec2(cos(x), sin(x));
}

/** Returns (a0 + j*a1)(b0 + j*b1) */
vec2 mul_complex(in vec2 a, in vec2 b) {
    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);
}

/** Returns the complex conjugate of x */
vec2 conj_complex(in vec2 x) {
    return vec2(x.x, -x.y);
}

// Jerry Tessendorf - Source: Simulating Ocean Water
float dispersion_relation(in float k) {
    return sqrt(G*k*tanh(k*uDepth));
}

#define FFT_DATA(id, layer) (data[(layer)*uMapSize*uMapSize + (id.y)*uMapSize + (id.x)])

void main() {
    const ivec2 dims = imageSize(spectrum);
    const ivec2 id = ivec2(gl_GlobalInvocationID.xy);

    if (id.x >= dims.x || id.y >= dims.y)
        return;

    vec2 k_vec = (id - dims*0.5)*2.0*PI / uTileLength; // Wave direction
    float k = length(k_vec) + 1e-6;
    vec2 k_unit = k_vec / k;

    // --- WAVE SPECTRUM MODULATION ---
    vec4 h0 = imageLoad(spectrum, id); // xy=h0(k), zw=conj(h0(-k))
    float dispersion = dispersion_relation(k) * uTime;
    vec2 modulation = exp_complex(dispersion);
    // Note: h respects the complex conjugation property
    vec2 h = mul_complex(h0.xy, modulation) + mul_complex(h0.zw, conj_complex(modulation));
    vec2 h_inv = vec2(-h.y, h.x); // Used to simplify complex multiplication operations

    // --- WAVE DISPLACEMENT CALCULATION ---
    vec2 hx = h_inv * k_unit.y;            // Equivalent: mul_complex(vec2(0, -k_unit.x), h);
    vec2 hy = h;
    vec2 hz = h_inv * k_unit.x;            // Equivalent: mul_complex(vec2(0, -k_unit.z), h);

    // --- WAVE GRADIENT CALCULATION ---
    // FIXME: i dont understand why k vectors need to be accessed yx instead of xy :(
    vec2 dhy_dx = h_inv * k_vec.y;         // Equivalent: mul_complex(vec2(0, k_vec.x), h);
    vec2 dhy_dz = h_inv * k_vec.x;         // Equivalent: mul_complex(vec2(0, k_vec.z), h);
    vec2 dhx_dx = -h * k_vec.y * k_unit.y; // Equivalent: mul_complex(vec2(k_vec.x * k_unit.x, 0), -h);
    vec2 dhz_dz = -h * k_vec.x * k_unit.x; // Equivalent: mul_complex(vec2(k_vec.y * k_unit.y, 0), -h);
    vec2 dhz_dx = -h * k_vec.y * k_unit.x; // Equivalent: mul_complex(vec2(k_vec.x * k_unit.y, 0), -h);

    // Because h respects the complex conjugation property (i.e., the output of IFFT will be a
    // real signal), we can pack two waves into one.
    FFT_DATA(id, 0) = vec2(    hx.x -     hy.y,     hx.y +     hy.x);
    FFT_DATA(id, 1) = vec2(    hz.x - dhy_dx.y,     hz.y + dhy_dx.x);
    FFT_DATA(id, 2) = vec2(dhy_dz.x - dhx_dx.y, dhy_dz.y + dhx_dx.x);
    FFT_DATA(id, 3) = vec2(dhz_dz.x - dhz_dx.y, dhz_dz.y + dhz_dx.x);
}
