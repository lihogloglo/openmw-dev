#version 440 core

// FFT Displacement Generation Shader
// Converts frequency domain data to displacement and normal maps

layout(local_size_x = 16, local_size_y = 16) in;

// Input: FFT result for height
layout(binding = 0, rgba32f) restrict readonly uniform image2D uHeightFFT;

// Outputs
layout(binding = 1, rgba32f) restrict writeonly uniform image2D uDisplacementMap;  // xyz displacement
layout(binding = 2, rgba32f) restrict writeonly uniform image2D uNormalMap;        // Normal vectors
layout(binding = 3, r32f) restrict writeonly uniform image2D uTempFoamMap;         // Temporary foam from Jacobian

// Uniforms
uniform float uTileSize;      // Physical tile size in meters
uniform float uChoppiness;    // Horizontal displacement multiplier
uniform int uN;               // Texture resolution

const float PI = 3.14159265359;
const float GRAVITY = 9.81;

// Complex multiplication
vec2 complexMult(vec2 a, vec2 b)
{
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

void main()
{
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(uHeightFFT);

    if (coord.x >= size.x || coord.y >= size.y)
        return;

    // Wave vector k
    vec2 k = vec2(
        (float(coord.x) - float(size.x) / 2.0) * 2.0 * PI / uTileSize,
        (float(coord.y) - float(size.y) / 2.0) * 2.0 * PI / uTileSize
    );

    float kLength = length(k);

    // Avoid division by zero
    if (kLength < 0.0001)
    {
        imageStore(uDisplacementMap, coord, vec4(0.0));
        imageStore(uNormalMap, coord, vec4(0.0, 0.0, 1.0, 0.0));
        imageStore(uTempFoamMap, coord, vec4(0.0));
        return;
    }

    // Normalized wave direction
    vec2 kNorm = k / kLength;

    // Read height spectrum (complex number)
    vec2 h = imageLoad(uHeightFFT, coord).xy;

    // Vertical displacement (height)
    float height = h.x;  // Real part

    // Horizontal displacement using Choppiness
    // Dx = -i * kx/k * h(k)
    // Dy = -i * ky/k * h(k)
    // Multiplying by -i is equivalent to swapping real/imag and negating
    vec2 horizontalDisp = vec2(-h.y * kNorm.x, -h.y * kNorm.y) * uChoppiness;

    // Displacement vector
    vec3 displacement = vec3(horizontalDisp.x, horizontalDisp.y, height);

    // Calculate derivatives for normals
    // dh/dx = i * kx * h(k)
    // dh/dy = i * ky * h(k)
    vec2 dhdx_complex = complexMult(vec2(0.0, 1.0), vec2(k.x, 0.0));
    vec2 dhdy_complex = complexMult(vec2(0.0, 1.0), vec2(k.y, 0.0));

    vec2 dhdx = complexMult(dhdx_complex, h);
    vec2 dhdy = complexMult(dhdy_complex, h);

    // Normal calculation: cross product of tangents
    // T1 = (1, 0, dh/dx)
    // T2 = (0, 1, dh/dy)
    // N = normalize(cross(T1, T2)) = normalize((-dh/dx, -dh/dy, 1))
    vec3 normal = normalize(vec3(-dhdx.x, -dhdy.x, 1.0));

    // Jacobian for foam (measures wave breaking)
    // J = (1 + dDx/dx) * (1 + dDy/dy) - (dDx/dy) * (dDy/dx)
    // Simplified: use negative values to indicate foam
    float jacobian = 1.0 - kLength * height * uChoppiness;
    float foam = clamp(-jacobian, 0.0, 1.0);

    // Store results
    imageStore(uDisplacementMap, coord, vec4(displacement, 1.0));
    imageStore(uNormalMap, coord, vec4(normal * 0.5 + 0.5, 1.0));  // Encode normal to [0,1]
    imageStore(uTempFoamMap, coord, vec4(foam, 0.0, 0.0, 0.0));  // Temporary foam for accumulation
}
